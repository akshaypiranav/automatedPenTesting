# TEAM SLYTHERIN - QUARSEK HACKATHON

"""
AKSHAY PIRANAV B -BACKEND
SIBI SIDDHARTHAN S - FRONT END 
NHIRANJAN MK - API HANDLER
VIJAYA MADAESHWAR - DB
"""

import requests
import socket
import nmap,os,shlex
from zapv2 import ZAPv2
import time,threading
import json,psutil,subprocess
from io import BytesIO
from xhtml2pdf import pisa
import concurrent.futures
from urllib.parse import urlparse

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

nmap_json_value=''
zap_json_value=''

#To add http protocol
def add_http_protocol(url):
    parsed_url = urlparse(url)
    if not parsed_url.scheme:
        return 'http://' + url
    return url


#checks wheather valid url or not
def is_valid_url(url):
    try:
        if not url.startswith(('http://', 'https://')):
            url = f"http://{url}" 
        response = requests.head(url, allow_redirects=True)
        response.raise_for_status()
        return True
    except requests.exceptions.RequestException as e:
        print(e)
        return False


#checks the URL status
def check_url_status(url):
    try:
        if not url.startswith(('http://', 'https://')):
            url = f"http://{url}" 
        response = requests.get(url)
        response.raise_for_status()  
        return response.status_code
    except requests.exceptions.RequestException as e:
        print(f"Error checking URL status: {e}")
        return None
    

#Gets IP address for Nmap
def get_ip_address(url):
    try:
        url = url.replace("http://", "").replace("https://", "")
        host = url.split('/')[0]
        ip_address = socket.gethostbyname(host)
        return ip_address
    except (socket.error, socket.gaierror) as e:
        print(f"Error resolving IP address for {url}: {e}")
        return None
    
#Generate PDF using Json Data 
def generate_pdf_from_json(json_result_nmap, json_result_zap,urlData):
    try:
        print("going to generate")
        
        if isinstance(json_result_nmap, str):
            json_result_nmap = json.loads(json_result_nmap)
        if isinstance(json_result_zap, str):
            json_result_zap = json.loads(json_result_zap)

        # Define HTML template
        html_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>PDF Report</title>

    </head>
    <body >
        <h1 style="font-weight: bold;text-align:center; font-size:30px;  "><b>Nmap Scan Result</b></h1>
        <h2 ><b>a. Summary - No. of Vulnerable Ports Open</b></h2>
        <p ><b>Total Count :</b> : <b >{nmap_summary}</b></p>
        <h2 "  ><b>b. Detailed Report</b></h2>
        {nmap_detailed_report}

        <h1 style="font-weight: bold;text-align:center; font-size:30px;  "><b><br>ZAP Scan Result</b></h1>
        <h2  ><b>a. Summary</b></h2>
        <p><b>i. No. of Total Vulnerabilities Identified: </b> : {zap_summary_count}</p>
        <p><b>ii. No. of Total Vulnerabilities Identified grouped on Risk Rating: </b> : {zap_risk_count}</p>
        <h2  ><b>b. Detailed Report</b></h2>
        {zap_detailed_report}
    </body>
    </html>
        """
        print("successfully reads the HTML")

        # Format Nmap detailed report
        nmap_detailed_report = ""
        if isinstance(json_result_nmap, dict):
            for port_info in json_result_nmap.get("Detailed Report", []):
                nmap_detailed_report += f"""
                
                <h3><b>i. Port Number: </b>{port_info.get("i. Port Number", "")}</h3>
                <p><b>ii. Protocol: </b>{port_info.get("ii. Protocol", "")}</p>
                <p><b>iii. Service: </b>{port_info.get("iii. Service", "")}</p>
                <p><b>iv. Recommended Action or Best Practices: </b>{port_info.get("iv. Recommended Action or Best Practices", "")}</p>
                
                """

        zap_detailed_report = ""
        if isinstance(json_result_zap, dict):
            for report in json_result_zap.get("Detailed Report", []):
                zap_detailed_report += f"""
                
                <div>
                <h3><b>i. Vulnerability Summary: </b>{report.get("Vulnerability Summary", "")}</h3>
                <p><b>ii. Risk Rating: </b>{report.get("Risk Rating", "")}</p>
                <p><b>iii. Confidence Rating: </b>{report.get("Confidence Rating", "")}</p>
                <p><b>iv. Description: </b>{report.get("Description", "")}</p>
                <p><b>v. Details to Reproduce the Instance:</b></p>
                <ul>
                    <li><b>URL: </b>{report["Details to Reproduce the Instance"].get("URL", "")}</li>
                    <li><b>Method: </b>{report["Details to Reproduce the Instance"].get("Method", "")}</li>
                    <li><b>Parameter: </b>{report["Details to Reproduce the Instance"].get("Parameter", "")}</li>
                    <li><b>Attack: </b>{report["Details to Reproduce the Instance"].get("Attack", "")}</li>
                    <li><b>Evidence: </b>{report["Details to Reproduce the Instance"].get("Evidence", "")}</li>
                </ul>
                """

        html_content = html_template.format(
            nmap_summary=json_result_nmap.get("Summary - No. of Vulnerable Ports Open", ""),
            nmap_detailed_report=nmap_detailed_report,
            zap_summary_count=json_result_zap.get("Summary", {}).get("No. of Total Vulnerabilities Identified", ""),
            zap_risk_count=json_result_zap.get("Summary", {}).get("No. of Total Vulnerabilities Identified grouped on Risk Rating", ""),
            zap_detailed_report=zap_detailed_report
        )

        output_file_path = 'output.pdf'

        # Open a file to write the PDF content
        with open(output_file_path, 'wb') as output_file:
            # Convert HTML to PDF and write to the file
            pdf_data = pisa.CreatePDF(html_content, dest=output_file)

        if not pdf_data.err:
            print(f"PDF generated successfully at: {output_file_path}")

            with open(output_file_path, 'rb') as pdf_file:
                pdf_content = pdf_file.read()

            # Open a BytesIO object to store the PDF content
            pdf_buffer = BytesIO()

            # Write the PDF content to the BytesIO object
            pdf_buffer.write(pdf_content)
            #Saving the Generated the PDF report To the DB
            urlData.generatedReport.save('output.pdf', pdf_buffer)
            urlData.save()
            from .models import Register
            
            #Sends Email to the User After PDF generation
            id_data_value_for_mail=urlData.user
            user_data_for_mail = urlData.user
            email_data = user_data_for_mail.email
            sender_email = "akshaypiranavb@gmail.com"
            subject = "URL REPORT REGARDS"
            body = f"Your {urlData.url} has succesfully scanned and generated the url. Login and Download the PDF from APT website"
            message = MIMEMultipart()
            message["From"] = sender_email
            message["To"] = email_data
            message["Subject"] = subject
            message.attach(MIMEText(body, "plain"))

            smtp_server = "smtp.gmail.com"
            smtp_port = 587
            smtp_username = "akshaypiranavb@gmail.com"
            smtp_password = "ddld flec vggd ovve"
            
            with smtplib.SMTP(smtp_server, smtp_port) as server:
                server.starttls()
                server.login(smtp_username, smtp_password)
                server.sendmail(sender_email, email_data, message.as_string())
            print("pdf generated")
        else:
            print(f"Error generating PDF: {pdf_data.err}")
    except Exception as e:
        urlData.url_status="Test Error"
        urlData.save()
        print(e)





#Recommendation for Nmap
def recommendations_for_service(service):
    # Define recommendations for each service
    recommendations = {
        'ftp': "Ensure secure FTP configurations. Consider using SFTP or FTPS instead.",
        'smtp': "Implement proper email filtering and authentication mechanisms.",
        'http': "Apply security headers, keep software updated, and implement secure coding practices.",
        'telnet': "Avoid using Telnet due to its lack of encryption. Use SSH instead.",
        'ssh': "Ensure strong SSH configurations, including key-based authentication and disabling root login.",
        'pop3': "Consider using POP3 over SSL/TLS (POP3S) for secure email retrieval.",
        'imap': "Implement IMAP with SSL/TLS (IMAPS) for secure email access.",
        'smb': "Ensure proper access controls and regular security updates for SMB shares.",
        'mysql': "Apply strong authentication, access controls, and regular patching for MySQL databases.",
        'mssql': "Implement strong authentication, access controls, and regular patching for MSSQL databases.",
        'postgresql': "Apply strong authentication, access controls, and regular patching for PostgreSQL databases.",
        'oracle': "Implement strong authentication, access controls, and regular patching for Oracle databases.",
        'vnc': "Use VNC over SSH or VPN for secure remote desktop access.",
        'rdp': "Secure RDP by using Network Level Authentication (NLA) and enforcing strong password policies.",
        'ldap': "Implement LDAP with SSL/TLS (LDAPS) for secure directory services.",
        'snmp': "Use SNMPv3 with strong authentication and encryption for secure network management.",
        'ntp': "Secure NTP servers by restricting access and using authentication mechanisms.",
        'irc': "Monitor IRC traffic for suspicious activities and apply proper access controls.",
        'xmpp': "Use XMPP with TLS for encrypted communication.",
        'git': "Ensure proper access controls and authentication mechanisms for Git repositories.",
        'svn': "Secure SVN repositories by enforcing access controls and regular audits.",
        'cvs': "Secure CVS repositories by enforcing access controls and regular audits.",
        'rsync': "Implement Rsync over SSH for secure file synchronization.",
        'mongodb': "Implement authentication, access controls, and encryption for MongoDB databases.",
        'memcached': "Implement proper access controls and restrict access to trusted clients.",
        'redis': "Implement proper access controls and enable authentication for Redis instances.",
        'dns': "Secure DNS servers by implementing DNSSEC and regular security updates.",
        'dhcp': "Implement DHCP snooping and port security to prevent DHCP attacks.",
        'tftp': "Avoid using TFTP due to its lack of security features. Use SCP or FTPS instead.",
        'rpcbind': "Limit RPC services to trusted networks and implement authentication mechanisms.",
        'ipp': "Secure IPP by using IPPS (IPP over SSL/TLS) and access controls.",
        'mdns': "Limit mDNS services to trusted networks and implement authentication mechanisms.",
        'printer': "Secure network printers by applying access controls and firmware updates.",
        'x11': "Avoid using X11 forwarding over untrusted networks. Use SSH with X11 forwarding.",
        'smtps': "Implement SMTPS (SMTP over SSL/TLS) for secure email transmission.",
        'pop3s': "Use POP3S (POP3 over SSL/TLS) for secure email retrieval.",
        'imaps': "Implement IMAPS (IMAP over SSL/TLS) for secure email access.",
        'http-alt': "Apply security best practices for alternative HTTP services.",
        'submission': "Secure email submission by using submission over SSL/TLS.",
        'ldaps': "Implement LDAPS (LDAP over SSL/TLS) for secure directory services.",
        'ms-wbt-server': "Secure MS-WBT Server by enabling Network Level Authentication (NLA) and enforcing strong password policies.",
        'zabbix-agent': "Implement proper access controls and encryption for Zabbix agents.",
        'zabbix-trapper': "Implement proper access controls and encryption for Zabbix trappers.",
        'zabbix-proxy': "Implement proper access controls and encryption for Zabbix proxies.",
        'zabbix-server': "Implement proper access controls and encryption for Zabbix servers.",
        'zabbix-java-gateway': "Implement proper access controls and encryption for Zabbix Java gateways.",
        'ftp-proxy': "Secure FTP proxy by implementing proper access controls and monitoring.",
        'smtp-proxy': "Secure SMTP proxy by implementing proper access controls and monitoring.",
        'pop3-proxy': "Secure POP3 proxy by implementing proper access controls and monitoring.",
        'imap-proxy': "Secure IMAP proxy by implementing proper access controls and monitoring.",
        'irc-proxy': "Secure IRC proxy by implementing proper access controls and monitoring.",
        'https': "Apply security best practices for HTTPS services.",
        'http-proxy': "Secure HTTP proxy by implementing proper access controls and monitoring.",
        'socks': "Use SOCKS over SSL/TLS for encrypted and authenticated communication.",
        'socks-proxy': "Secure SOCKS proxy by implementing proper access controls and monitoring.",
        'https-alt': "Apply security best practices for alternative HTTPS services.",
        'afp': "Implement AFP over SSL/TLS for secure file sharing.",
        'openvpn': "Ensure strong encryption and authentication for OpenVPN connections.",
        'socks5': "Use SOCKS5 over SSL/TLS for encrypted and authenticated communication.",
        'msrpc': "Secure MSRPC services by limiting access to trusted networks and implementing authentication mechanisms.",
        'mountd': "Secure NFS mountd service by limiting access to trusted networks and implementing access controls.",
        'nfsd': "Secure NFS services by limiting access to trusted networks and implementing access controls.",
        'nfs_acl': "Secure NFS ACL by implementing proper access controls and monitoring.",
        'nfsacl': "Secure NFS ACL by implementing proper access controls and monitoring.",
        'filenet-powsrmgr': "Ensure proper access controls and authentication mechanisms for FileNet PowerServer Manager.",
        'sunrpc': "Limit access to SunRPC services to trusted networks and implement authentication mechanisms.",
        'nfsd-status': "Secure NFS status service by limiting access to trusted networks and implementing access controls.",
        'ms-sql-s': "Secure MS-SQL Server by implementing strong authentication and access controls.",
        'ms-sql-m': "Secure MS-SQL Server by implementing strong authentication and access controls.",
        'oracle-tns': "Secure Oracle TNS listener by implementing access controls and encryption.",
        'rsh': "Avoid using RSH due to its lack of security features. Use SSH instead.",
        'ntp': "Ensure proper access controls and authentication for NTP servers.",
        'netbios-ssn': "Secure NetBIOS services by restricting access and implementing authentication mechanisms.",
        'ldap': "Implement LDAP with SSL/TLS (LDAPS) for secure directory services.",
        'vnc': "Use VNC over SSH or VPN for secure remote desktop access.",
        'irc': "Monitor IRC traffic for suspicious activities and apply proper access controls.",
        'xmpp': "Use XMPP with TLS for encrypted communication.",
        'mdns': "Limit mDNS services to trusted networks and implement authentication mechanisms.",
        'printer': "Secure network printers by applying access controls and firmware updates.",
        'tftp': "Avoid using TFTP due to its lack of security features. Use SCP or FTPS instead.",
        'svn': "Secure SVN repositories by enforcing access controls and regular audits.",
        'git': "Ensure proper access controls and authentication mechanisms for Git repositories.",
        'cvs': "Secure CVS repositories by enforcing access controls and regular audits.",
        'ssh': "Ensure strong SSH configurations, including key-based authentication and disabling root login.",
        'rsync': "Implement Rsync over SSH for secure file synchronization.",
        'mongodb': "Implement authentication, access controls, and encryption for MongoDB databases.",
        'memcached': "Implement proper access controls and restrict access to trusted clients.",
        'redis': "Implement proper access controls and enable authentication for Redis instances.",
        'ircs': "Use IRC over SSL/TLS for encrypted communication."
    }
    default_recommendation = "Implement proper access controls, keep software updated, and regularly perform security audits."

    if service.lower() in recommendations:
        return recommendations[service.lower()]
    else:
        return default_recommendation


#Checks With  the Services
def is_vulnerable(service):
    vulnerable_services = [
        'ftp', 'smtp', 'http', 'telnet', 'ssh', 'pop3', 'imap', 'smb', 'mysql', 'mssql',
        'postgresql', 'oracle', 'vnc', 'rdp', 'ldap', 'snmp', 'ntp', 'irc', 'ircs', 'xmpp',
        'git', 'svn', 'cvs', 'rsync', 'mongodb', 'memcached', 'redis', 'ftp-data', 'postgres',
        'netbios-ssn', 'pptp', 'kerberos', 'kerberos-sec', 'dns', 'dhcp', 'tftp', 
        'rpcbind', 'ipp', 'mdns', 'printer', 'x11', 'nfs', 'smtps', 
        'pop3s', 'imaps', 'http-alt', 'microsoft-ds', 'submission', 'ldaps', 
        'ms-wbt-server', 'zabbix-agent', 'zabbix-trapper', 'zabbix-proxy', 'zabbix-server', 
        'zabbix-java-gateway', 'ftp-proxy', 'smtp-proxy', 'pop3-proxy', 'imap-proxy', 'irc-proxy', 
        'https', 'http-proxy', 'socks', 'socks-proxy', 'https-alt', 'afp', 'openvpn', 
        'socks5', 'msrpc', 'mountd', 'nfsd', 'nfs_acl', 'nfsacl', 
        'filenet-powsrmgr', 'sunrpc', 'nfsd-status', 'ms-sql-s',
        'ms-sql-m', 'oracle-tns', 'rsh', 'ftp', 'ftp-data', 'ntp', 'netbios-ssn', 
        'snmp', 'ldap', 'vnc', 'irc', 'xmpp', 'mdns', 'printer', 'tftp', 'ssh', 
        'rsync', 'mongodb', 'memcached', 'redis'
    ]
    return service.lower() in vulnerable_services


#Perform Nmap
def perform_nmap_scan(target_ip, urlData):
    result = {
        'Summary - No. of Vulnerable Ports Open': 0,
        'Detailed Report': []
    }

    try:
        print("SCANNER INITIATED\n\n\n\n")
        print("AKSHAY")
        nm = nmap.PortScanner()
        print("Scanner started")

        nm.scan(target_ip, arguments='-p 1-1000 --min-parallelism 10 --max-parallelism 50')
        #nm.scan(target_ip, arguments='-p 1-65535 --min-parallelism 10 --max-parallelism 50')

        print("Scanning started")

        vulnerable_ports = []

        for host in nm.all_hosts():
            for proto in nm[host].all_protocols():
                ports = nm[host][proto].keys()
                for port in ports:
                    service = nm[host][proto][port]['name'] if 'name' in nm[host][proto][port] else 'Unknown'
                    state = nm[host][proto][port]['state']

                    if is_vulnerable(service):
                        result['Summary - No. of Vulnerable Ports Open'] += 1
                        vulnerable_ports.append({
                            'i. Port Number': port,
                            'ii. Protocol': proto,
                            'iii. Service': service,
                            'iv. Recommended Action or Best Practices': recommendations_for_service(service)
                        })

        result['Detailed Report'] = vulnerable_ports

    except Exception as e:
        #If Nmap not Completed its process changing the url Status
        urlData.url_status = "Test Error"
        urlData.save()




    json_result_nmap = json.dumps(result, indent=4)
    return json_result_nmap


#Perform Zap
def run_zap_scan(zap_url, api_key, target_url, urlData):
    result = {
        "Summary": {
            "No. of Total Vulnerabilities Identified": 0,
            "No. of Total Vulnerabilities Identified grouped on Risk Rating": {}
        },
        "Detailed Report": []
    }

    try:
        zap = ZAPv2(apikey=api_key)
        context_id = zap.context.new_context('my_context')
        zap.context.include_in_context(context_id, target_url)

        print("Starting ZAP Spider...")
        scan_id = zap.spider.scan(target_url)
        while True:
            status = zap.spider.status(scan_id)
            if status == '100':
                print("ZAP Spider completed.")
                break
            time.sleep(1)
        print("Starting ZAP Active Scan...")
        scan_id = zap.ascan.scan(target_url)

        while True:
            status = zap.ascan.status(scan_id)
            if status == '100':
                print("ZAP Active Scan completed.")
                break
            time.sleep(1)
        time.sleep(5)

        alerts = zap.core.alerts()

        total_vulnerabilities = 0
        vulnerabilities_by_risk = {}

        detailed_reports = []

        for alert in alerts:
            total_vulnerabilities += 1

            risk = alert["risk"]
            if risk in vulnerabilities_by_risk:
                vulnerabilities_by_risk[risk] += 1
            else:
                vulnerabilities_by_risk[risk] = 1

            detailed_report = {
                "Vulnerability Summary": alert["name"],
                "Risk Rating": alert["risk"],
                "Confidence Rating": alert["confidence"],
                "Description": alert["description"],
                "Details to Reproduce the Instance": {
                    "URL": alert["url"],
                    "Method": alert["method"],
                    "Parameter": alert["param"] if alert["param"] else "No parameter specified",
                    "Attack": alert["attack"] if alert["attack"] else "No attack specified",
                    "Evidence": alert["evidence"] if alert["evidence"] else "No evidence available"
                }
            }

            detailed_reports.append(detailed_report)

        result["Summary"]["No. of Total Vulnerabilities Identified"] = total_vulnerabilities
        result["Summary"]["No. of Total Vulnerabilities Identified grouped on Risk Rating"] = vulnerabilities_by_risk
        result["Detailed Report"] = detailed_reports

        #If Zap Completed its process changing the url Status
        urlData.url_status = "Completed"
        urlData.save()

    except Exception as e:
        #If not Zap Completed its process changing the url Status
        urlData.url_status = "Test Error"
        urlData.save()
        print(f"An error occurred: {e}")

    # Convert result dictionary to JSON
    json_result_zap = json.dumps(result, indent=4)
    return json_result_zap

    


#Main function Calls Nmap and Zap
def main(target_ip_value,target_url_value,urlData):
    target_ip = target_ip_value
    zap_url = 'http://localhost:8080'
    api_key = 'lu58e3pa4ddiihfp7e6bfrtauv'
    target_url = target_url_value
    target_url = add_http_protocol(target_url)
    print(target_url)
    #Sets In Progress
    urlData.url_status="In Progress"
    urlData.save()
    print("Url Status : ",urlData.url_status)
    with concurrent.futures.ThreadPoolExecutor() as executor:
        nmap_future = executor.submit(perform_nmap_scan, target_ip, urlData)
        zap_future = executor.submit(run_zap_scan, zap_url, api_key, target_url, urlData)
        json_result_nmap = nmap_future.result()
        json_result_zap = zap_future.result()
        json_result_nmap = json.loads(json_result_nmap)
        json_result_zap = json.loads(json_result_zap)
        
        if json_result_nmap is not None and json_result_zap is not None:
            generate_pdf_from_json(json_result_nmap, json_result_zap,urlData)
        else:
            print("Error: Nmap or ZAP scan failed.")
        
        



#To start Zap Automatically
def start_zap_background():
    print("checking zap status")
    zap_jar_path = r"C:\Program Files\ZAP\Zed Attack Proxy\zap-2.14.0.jar"
    zap_command = ["java", "-Xmx2G", "-jar", zap_jar_path]
    
    def is_zap_running():
        for process in psutil.process_iter(['pid', 'name']):
            if "java.exe" in process.info['name'] and zap_jar_path in process.cmdline():
                return True
        return False
    
    if not is_zap_running():
        def start_zap_thread():
            try:
                subprocess.run(zap_command, check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error starting ZAP: {e}")

        zap_thread = threading.Thread(target=start_zap_thread)
        zap_thread.start()
    else:
        print("ZAP is already running.")


#To Start Redis Server Automatically
def start_redis_server(redis_path, port):
    redis_server_path = os.path.join(redis_path, "redis-server.exe")
    command = f'"{redis_server_path}" --port {port}'
    subprocess.Popen(shlex.split(command), cwd=redis_path)

#To start Redis Client Automatically
def start_redis_cli(redis_path, port):
    redis_cli_path = os.path.join(redis_path, "redis-cli.exe")
    command = f'"{redis_cli_path}" -p {port}'
    subprocess.Popen(shlex.split(command), cwd=redis_path)

#To start our Celery worker Automatically
def start_celery_worker(project_path):
    celery_command = 'celery -A AutomatedPenTesting.celery worker --pool=solo -l INFO'
    subprocess.Popen(shlex.split(celery_command), cwd=project_path)

#To check wheather the process is running or not
def is_process_running(process_name):
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['name'] == process_name:
            return True
    return False

#To start all the requirements Automatically while giving python manage.py runserver
def start_requirements():
    redis_path = "C:\\Program Files\\Redis"
    redis_port = 6380
    project_path = "E:\\AutomatedPenTesting"
    
    if not is_process_running("redis-server.exe"):
        start_redis_server(redis_path, redis_port)
    else:
        print("Redis server is already running.")

    if not is_process_running("celery"):
        start_celery_worker(project_path)
    else:
        print("Celery worker is already running.")
